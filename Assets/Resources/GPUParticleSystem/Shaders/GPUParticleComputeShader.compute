CGPROGRAM

// TODO: Fix comment: Update kernel
#pragma kernel UPDATE


StructuredBuffer<float4> gPositionIN;
StructuredBuffer<float4> gVelocityIN;
StructuredBuffer<float4> gAmbientIN;
StructuredBuffer<float4> gLifetimeIN;

RWStructuredBuffer<float4> gPositionOUT;
RWStructuredBuffer<float4> gVelocityOUT;
RWStructuredBuffer<float4> gAmbientOUT;
RWStructuredBuffer<float4> gLifetimeOUT;

uniform int gMaxParticleCount;
uniform float gDeltaTime;

uniform float3 gConstantAcceleration;
uniform float gConstantDrag;

uniform int gAttractorCount;
StructuredBuffer<float4> gAttractorBuffer;


struct VectorField
{

    float3 mPosition;
    float mRadius;
    float4 mVector;

};
uniform int gVectorFieldCount;
StructuredBuffer<VectorField> gVectorFieldBuffer;

uniform int gSphereColliderCount;
StructuredBuffer<float4> gSphereColliderBuffer;

RWStructuredBuffer<int> gSphereColliderResultBufferWRITE;

[numthreads(64,1,1)]
void UPDATE(uint3 id : SV_DispatchThreadID)
{
    int tID = (int)id.x;

    if (tID >= gMaxParticleCount) return;

    float2 pLifetime = gLifetimeIN[tID].xy;

    if (pLifetime.x < -0.3f) return;

    float3 pPosition = gPositionIN[tID].xyz;
    float3 pVelocity = gVelocityIN[tID].xyz;
    float3 pAmbient = gAmbientIN[tID].xyz;

    // Update position.
    pPosition = pPosition + pVelocity * gDeltaTime;

    // Update velocity (acceleration).
    pVelocity = pVelocity + gConstantAcceleration * gDeltaTime;

    // Update velocity (drag).
    pVelocity = pVelocity - pVelocity * (gConstantDrag * gDeltaTime);

    // Update velocity (attractors).
    int attractorCount = gAttractorCount;
    for (int i = 0; i < attractorCount; ++i)
    {
        float4 attractor = gAttractorBuffer[i];
        float3 aPosition = attractor.xyz;
        float aPower = attractor.w;

        float3 acceleratorDirection = aPosition - pPosition;
        float distance = length(acceleratorDirection);

        if (distance > 0.1f)
        {
            acceleratorDirection = normalize(acceleratorDirection);

            float distanceFactor = clamp(1.f / (distance * distance), 0, 1.f);
            float acceleration = aPower * distanceFactor;

            pVelocity = pVelocity + acceleratorDirection * (acceleration * gDeltaTime);
        }
    }

    // Update velocity (vector fields).
    int vectorFieldCount = gVectorFieldCount;
    for (int i = 0; i < vectorFieldCount; ++i)
    {
        VectorField vectorField = gVectorFieldBuffer[i];
        float3 vPosition = vectorField.mPosition;
        float vRadius = vectorField.mRadius;
        float3 vVector = vectorField.mVector.xyz;

        float3 vectorFieldDirection = vPosition - pPosition;
        float distance = length(vectorFieldDirection);

        if(distance < vRadius)
        {
        
            pVelocity = pVelocity + vVector * gDeltaTime;
        }
    }

    // Update collider (sphere).
    int sphereColliderCount = gSphereColliderCount;
    if (sphereColliderCount > 0)
    {

        if (tID < sphereColliderCount)
        {
            gSphereColliderResultBufferWRITE[tID] = 0;
        }

        //TODO BARRIER!!

        for (int i = 0; i < sphereColliderCount; ++i)
        {
            float4 sphereCollider = gSphereColliderBuffer[i];
            float3 cPosition = sphereCollider.xyz;
            float cRadius = sphereCollider.w;

            float3 cDirection = cPosition - pPosition;
            float cDistance = length(cDirection);

            if (cDistance < cRadius)
            {
                InterlockedAdd(gSphereColliderResultBufferWRITE[i], 1);
            }
        }
    }

    // Update lifetime.
    pLifetime.x = pLifetime.x - gDeltaTime;


    gPositionOUT[tID] = float4(pPosition, 0);
    gVelocityOUT[tID] = float4(pVelocity, 0);
    gAmbientOUT[tID] = float4(pAmbient, 0);
    gLifetimeOUT[tID] = float4(pLifetime.xy, 0, 0);
}

// Emitt kernel
#pragma kernel EMITT

RWStructuredBuffer<float4> gPositionBuffer;
RWStructuredBuffer<float4> gVelocityBuffer;
RWStructuredBuffer<float4> gAmbientBuffer;
RWStructuredBuffer<float4> gLifetimeBuffer;

uniform int gEmittIndex;
uniform float3 gPosition;
uniform float3 gVelocity;
uniform float3 gAmbient;
uniform float gLifetime;

uniform StructuredBuffer<float3> gEmittMeshVertexBuffer;
uniform StructuredBuffer<int> gEmittMeshIndexBuffer;
uniform int gEmittMeshVertexCount;
uniform int gEmittMeshIndexCount;
uniform int gEmittMeshRandomIndex;
uniform float3 gEmittMeshScale;

[numthreads(1, 1, 1)]
void EMITT(uint3 id : SV_DispatchThreadID)
{
    int index = gEmittIndex;

    float3 emittPosition = gPosition;
    if (gEmittMeshIndexCount > 0)
        emittPosition += gEmittMeshVertexBuffer[gEmittMeshIndexBuffer[gEmittMeshRandomIndex]] * gEmittMeshScale;

    gPositionBuffer[index] = float4(emittPosition, 0);
    gVelocityBuffer[index] = float4(gVelocity, 0);
    gAmbientBuffer[index] = float4(gAmbient, 0);

    float lifetime = gLifetime;
    gLifetimeBuffer[index] = float4(lifetime, lifetime, 0, 0);
}


// Update kernel
#pragma kernel RESULT

StructuredBuffer<int> gGPUColliderResultBufferIN;
RWStructuredBuffer<int> gGPUColliderResultBufferOUT;

StructuredBuffer<int> gSphereColliderResultBufferREAD;

uniform int gGPUColliderCount;
uniform bool gInitZero;

[numthreads(64, 1, 1)]
void RESULT(uint3 id : SV_DispatchThreadID)
{
    int tID = (int)id.x;

    int gpuColliderCount = gGPUColliderCount;

    if (tID >= gpuColliderCount) return;

    int value = gSphereColliderResultBufferREAD[tID];
    
    if (gInitZero)
    {
        gGPUColliderResultBufferOUT[tID] = value;
    }
    else
    {
        gGPUColliderResultBufferOUT[tID] = gGPUColliderResultBufferIN[tID] + value;
    }
}

ENDCG
